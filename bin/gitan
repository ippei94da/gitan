#! /usr/bin/env ruby
# coding: utf-8

#gitan heads
# Show hash value of every git repository.
#
#gitan status
# Show status of every git working trees.
# Confirm the command 'git rev-parse FETCH_HEAD' show a hash value.
# If not, you should execute 'git pull'
#
#gitan commit
# Commit every working tree that has changes to be be commited.
#
#gitan push
# Commit every working tree that has changes to be pushed.
#
#gitan pull
# Pull every working tree that has update on remote.

require "optparse"
require "yaml"
require "pp"
require "gitan"

def show_usage
  puts <<-HERE
USAGE
  gitan heads  [path]"
  gitan status [path] [-r remote_repo]"
  gitan commit [path] [-a arguments]"
  gitan push   [path] [-a arguments]"
  gitan pull   [path] [-a arguments] [-r remote_repo]"

  Default value of 'path' is ~/git.

  Examples:
    gitan heads /home/git
    gitan status -r example.com:/home/git
    gitan commit --argument='-am "commit message"'
    gitan push -a "origin master"
    gitan pull ~/git -r example.com:/home/git -a "origin master"
  HERE
end

def add_remote_option
  OPTION_PARSER.on("-r repo", "--remote=repo", "with remote info"){ |repo|
    server, path = repo.split(":")
    OPTIONS[:remote] = Gitan.remote_heads(server, path)
  }
end

def add_argument_option
  OPTION_PARSER.on("-a str", "--arguments=str", "supply argument to command"){ |str|
    OPTIONS[:argument] = str
  }
end

def repositories
  git_dir = ENV["HOME"] + "/git"
  git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  dirs = Dir.glob(git_dir + "/*").sort.map do |path|
    if File.directory? path
      Gitan::Repo.new(path, nil)
    else
      nil
    end
  end
  dirs.select{|dir| dir}
end

def execute(path, command)
  print "#{path}: "
  Dir.chdir path
  puts command
  system command unless OPTIONS[:debug]
end


def status
  add_remote_option
  OPTION_PARSER.parse!(ARGV)

  git_dir = ENV["HOME"] + "/git"
  git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  Gitan::Repo.show_abbreviation($stdout)
  Dir.glob(git_dir + "/*").sort.map do |path|
    next unless File.directory? path
    head = OPTIONS[:remote][File.basename(path)] if OPTIONS[:remote]
    repo = Gitan::Repo.new(path, head)
    puts repo.short_status
  end
end

def heads
  git_dir = ENV["HOME"] + "/git"
  git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  results = {}
  Dir.glob(git_dir + "/*").sort.map do |path|
    next unless File.directory? path
    repo = Gitan::Repo.new(path)
    results[path] = repo.head
  end

  YAML.dump(results, $stdout)
end

def commit
  add_argument_option
  OPTION_PARSER.parse!(ARGV)

  repositories.select {|repo| repo.to_be_commited?}.each do |repo|
    execute(repo.path, "git commit #{OPTIONS[:argument]}")
  end
  #git_dir = ENV["HOME"] + "/git"
  #git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  #Dir.glob(git_dir + "/*").sort.map do |path|
  #  next unless File.directory? path
  #  repo = Gitan::Repo.new(path, nil)
  #  if repo.to_be_commited?
  #    print "#{path}: "
  #    Dir.chdir path
  #    command = "git commit #{OPTIONS[:argument]}"
  #    puts command
  #    system command unless OPTIONS[:debug]
  #  end
  #end
end

def push
  add_argument_option
  OPTION_PARSER.parse!(ARGV)

  git_dir = ENV["HOME"] + "/git"
  git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  Dir.glob(git_dir + "/*").sort.map do |path|
    next unless File.directory? path
    repo = Gitan::Repo.new(path, nil)
    if repo.to_be_pushed?
      print "#{path}: "
      Dir.chdir path
      command = "git push #{OPTIONS[:argument]}"
      puts command
      system command unless OPTIONS[:debug]
    end
  end
end

def pull
  add_remote_option
  add_argument_option
  OPTION_PARSER.parse!(ARGV)
  git_dir = ENV["HOME"] + "/git"
  git_dir = File::expand_path(ARGV[0]) if ARGV[0]

  Dir.glob(git_dir + "/*").sort.map do |path|
    next unless File.directory? path
    head = OPTIONS[:remote][File.basename(path)] if OPTIONS[:remote]
    repo = Gitan::Repo.new(path, head)
    if repo.to_be_pulled?
      print "#{path}: "
      Dir.chdir path
      command = "git pull #{OPTIONS[:argument]}"
      puts command
      system command unless OPTIONS[:debug]
    end
  end
end

##main
OPTIONS = {}
OPTION_PARSER = OptionParser.new
OPTION_PARSER.on("-d", "--debug", "debug mode."){OPTIONS[:debug] = true}
command = ARGV.shift

case command
when "status"
  status
when "heads"
  heads
when "commit"
  commit
when "push"
  push
when "pull"
  pull
when "--help"
  show_usage
else
  puts "Unknown command: #{command}"
  show_usage
end
